
rensha.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000004a  00800100  00000496  0000052a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000496  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000c  0080014a  0080014a  00000574  2**0
                  ALLOC
  3 .stab         000006fc  00000000  00000000  00000574  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000000e5  00000000  00000000  00000c70  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000e0  00000000  00000000  00000d55  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000211  00000000  00000000  00000e35  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00000ae5  00000000  00000000  00001046  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000688  00000000  00000000  00001b2b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000c01  00000000  00000000  000021b3  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001b0  00000000  00000000  00002db4  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000034b  00000000  00000000  00002f64  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000201  00000000  00000000  000032af  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 0000013a  00000000  00000000  000034b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000010  00000000  00000000  000035ea  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	29 c0       	rjmp	.+82     	; 0x54 <__ctors_end>
   2:	43 c0       	rjmp	.+134    	; 0x8a <__bad_interrupt>
   4:	42 c0       	rjmp	.+132    	; 0x8a <__bad_interrupt>
   6:	e4 c0       	rjmp	.+456    	; 0x1d0 <__vector_3>
   8:	21 c1       	rjmp	.+578    	; 0x24c <__vector_4>
   a:	3f c0       	rjmp	.+126    	; 0x8a <__bad_interrupt>
   c:	3e c0       	rjmp	.+124    	; 0x8a <__bad_interrupt>
   e:	3d c0       	rjmp	.+122    	; 0x8a <__bad_interrupt>
  10:	3c c0       	rjmp	.+120    	; 0x8a <__bad_interrupt>
  12:	3b c0       	rjmp	.+118    	; 0x8a <__bad_interrupt>
  14:	3a c0       	rjmp	.+116    	; 0x8a <__bad_interrupt>
  16:	39 c0       	rjmp	.+114    	; 0x8a <__bad_interrupt>
  18:	38 c0       	rjmp	.+112    	; 0x8a <__bad_interrupt>
  1a:	d2 c1       	rjmp	.+932    	; 0x3c0 <__vector_13>
  1c:	36 c0       	rjmp	.+108    	; 0x8a <__bad_interrupt>
  1e:	35 c0       	rjmp	.+106    	; 0x8a <__bad_interrupt>
  20:	34 c0       	rjmp	.+104    	; 0x8a <__bad_interrupt>
  22:	33 c0       	rjmp	.+102    	; 0x8a <__bad_interrupt>
  24:	8d c1       	rjmp	.+794    	; 0x340 <__vector_18>
  26:	31 c0       	rjmp	.+98     	; 0x8a <__bad_interrupt>
  28:	30 c0       	rjmp	.+96     	; 0x8a <__bad_interrupt>
  2a:	2f c0       	rjmp	.+94     	; 0x8a <__bad_interrupt>
  2c:	2e c0       	rjmp	.+92     	; 0x8a <__bad_interrupt>
  2e:	2d c0       	rjmp	.+90     	; 0x8a <__bad_interrupt>
  30:	2c c0       	rjmp	.+88     	; 0x8a <__bad_interrupt>
  32:	2b c0       	rjmp	.+86     	; 0x8a <__bad_interrupt>
  34:	91 c0       	rjmp	.+290    	; 0x158 <debughex+0x14>
  36:	93 c0       	rjmp	.+294    	; 0x15e <debughex+0x1a>
  38:	95 c0       	rjmp	.+298    	; 0x164 <debughex+0x20>
  3a:	97 c0       	rjmp	.+302    	; 0x16a <debughex+0x26>
  3c:	99 c0       	rjmp	.+306    	; 0x170 <debughex+0x2c>
  3e:	9b c0       	rjmp	.+310    	; 0x176 <debughex+0x32>
  40:	9d c0       	rjmp	.+314    	; 0x17c <debughex+0x38>
  42:	9f c0       	rjmp	.+318    	; 0x182 <debughex+0x3e>
  44:	a1 c0       	rjmp	.+322    	; 0x188 <debughex+0x44>
  46:	a3 c0       	rjmp	.+326    	; 0x18e <debughex+0x4a>
  48:	a5 c0       	rjmp	.+330    	; 0x194 <debughex+0x50>
  4a:	a7 c0       	rjmp	.+334    	; 0x19a <debughex+0x56>
  4c:	a9 c0       	rjmp	.+338    	; 0x1a0 <debughex+0x5c>
  4e:	ab c0       	rjmp	.+342    	; 0x1a6 <debughex+0x62>
  50:	ad c0       	rjmp	.+346    	; 0x1ac <debughex+0x68>
  52:	af c0       	rjmp	.+350    	; 0x1b2 <debughex+0x6e>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf ef       	ldi	r28, 0xFF	; 255
  5a:	d4 e0       	ldi	r29, 0x04	; 4
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	11 e0       	ldi	r17, 0x01	; 1
  62:	a0 e0       	ldi	r26, 0x00	; 0
  64:	b1 e0       	ldi	r27, 0x01	; 1
  66:	e6 e9       	ldi	r30, 0x96	; 150
  68:	f4 e0       	ldi	r31, 0x04	; 4
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	aa 34       	cpi	r26, 0x4A	; 74
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	11 e0       	ldi	r17, 0x01	; 1
  78:	aa e4       	ldi	r26, 0x4A	; 74
  7a:	b1 e0       	ldi	r27, 0x01	; 1
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a6 35       	cpi	r26, 0x56	; 86
  82:	b1 07       	cpc	r27, r17
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	11 d1       	rcall	.+546    	; 0x2aa <main>
  88:	b3 c1       	rjmp	.+870    	; 0x3f0 <exit>

0000008a <__bad_interrupt>:
  8a:	ba cf       	rjmp	.-140    	; 0x0 <__vectors>

0000008c <Autofire_P1B1_Changed>:
#include "asm.h"


void Autofire_P1B1_Changed(uint8_t v)
{
	if (v)
  8c:	88 23       	and	r24, r24
  8e:	11 f0       	breq	.+4      	; 0x94 <Autofire_P1B1_Changed+0x8>
	{
		bit_set(PORTD, _BV(2));
  90:	5a 9a       	sbi	0x0b, 2	; 11
  92:	08 95       	ret
	}
	else
	{
		bit_clear(PORTD, _BV(2));
  94:	5a 98       	cbi	0x0b, 2	; 11
  96:	08 95       	ret

00000098 <Autofire_P1B2_Changed>:
	}
}

void Autofire_P1B2_Changed(uint8_t v)
{
	if (v)
  98:	88 23       	and	r24, r24
  9a:	11 f0       	breq	.+4      	; 0xa0 <Autofire_P1B2_Changed+0x8>
	{
		bit_set(PORTD, _BV(3));
  9c:	5b 9a       	sbi	0x0b, 3	; 11
  9e:	08 95       	ret
	}
	else
	{
		bit_clear(PORTD, _BV(3));
  a0:	5b 98       	cbi	0x0b, 3	; 11
  a2:	08 95       	ret

000000a4 <Autofire_P1B3_Changed>:
	}
}

void Autofire_P1B3_Changed(uint8_t v)
{
	if (v)
  a4:	88 23       	and	r24, r24
  a6:	11 f0       	breq	.+4      	; 0xac <Autofire_P1B3_Changed+0x8>
	{
		bit_set(PORTD, _BV(4));
  a8:	5c 9a       	sbi	0x0b, 4	; 11
  aa:	08 95       	ret
	}
	else
	{
		bit_clear(PORTD, _BV(4));
  ac:	5c 98       	cbi	0x0b, 4	; 11
  ae:	08 95       	ret

000000b0 <Autofire_P1START_Changed>:
	}
}

void Autofire_P1START_Changed(uint8_t v)
{
	if (v)
  b0:	88 23       	and	r24, r24
  b2:	11 f0       	breq	.+4      	; 0xb8 <Autofire_P1START_Changed+0x8>
	{
		bit_set(PORTD, _BV(5));
  b4:	5d 9a       	sbi	0x0b, 5	; 11
  b6:	08 95       	ret
	}
	else
	{
		bit_clear(PORTD, _BV(5));
  b8:	5d 98       	cbi	0x0b, 5	; 11
  ba:	08 95       	ret

000000bc <Autofire_Init>:
}

void Autofire_Init()
{
	/* P1UP on port C, pin 0 */
	bit_set(DDRC, _BV(0));  // output
  bc:	38 9a       	sbi	0x07, 0	; 7
	bit_set(PORTC, _BV(0)); // high value
  be:	40 9a       	sbi	0x08, 0	; 8

	/* P1DOWN on port C, pin 1 */
	bit_set(DDRC, _BV(1));  // output
  c0:	39 9a       	sbi	0x07, 1	; 7
	bit_set(PORTC, _BV(1)); // high value
  c2:	41 9a       	sbi	0x08, 1	; 8
	
	/* P1LEFT on port D, pin 6 */
	bit_set(DDRD, _BV(6));  // output
  c4:	56 9a       	sbi	0x0a, 6	; 10
	bit_set(PORTD, _BV(6)); // high value
  c6:	5e 9a       	sbi	0x0b, 6	; 11

	/* P1RIGHT on port D, pin 7 */
	bit_set(DDRD, _BV(7));  // output
  c8:	57 9a       	sbi	0x0a, 7	; 10
	bit_set(PORTD, _BV(7)); // high value
  ca:	5f 9a       	sbi	0x0b, 7	; 11
	
	/* P1B1 input on port B, pin 0 (PCINT0_pin); output on port D, pin 2 */
	bit_clear(DDRB, _BV(0)); // input
  cc:	20 98       	cbi	0x04, 0	; 4
	bit_set(PORTB, _BV(0));  // pull-up
  ce:	28 9a       	sbi	0x05, 0	; 5
	bit_set(PCMSK0, _BV(PCINT0)); // enable contribution to PCINT0_int
  d0:	eb e6       	ldi	r30, 0x6B	; 107
  d2:	f0 e0       	ldi	r31, 0x00	; 0
  d4:	80 81       	ld	r24, Z
  d6:	81 60       	ori	r24, 0x01	; 1
  d8:	80 83       	st	Z, r24
	bit_set(DDRD, _BV(2));  // output
  da:	52 9a       	sbi	0x0a, 2	; 10
	bit_set(PORTD, _BV(2)); // high value
  dc:	5a 9a       	sbi	0x0b, 2	; 11
	
	/* P1B2 input on port B, pin 1 (PCINT1_pin); output on port D, pin 3 */
	bit_clear(DDRB, _BV(1)); // input
  de:	21 98       	cbi	0x04, 1	; 4
	bit_set(PORTB, _BV(1));  // pull-up
  e0:	29 9a       	sbi	0x05, 1	; 5
	bit_set(PCMSK0, _BV(PCINT1)); // enable contribution to PCINT0_int
  e2:	80 81       	ld	r24, Z
  e4:	82 60       	ori	r24, 0x02	; 2
  e6:	80 83       	st	Z, r24
	bit_set(DDRD, _BV(3));  // output
  e8:	53 9a       	sbi	0x0a, 3	; 10
	bit_set(PORTD, _BV(3)); // high value
  ea:	5b 9a       	sbi	0x0b, 3	; 11

	/* P1B3 input on port B, pin 2 (PCINT2_pin); output on port D, pin 4 */
	bit_clear(DDRB, _BV(2)); // input
  ec:	22 98       	cbi	0x04, 2	; 4
	bit_set(PORTB, _BV(2));  // pull-up
  ee:	2a 9a       	sbi	0x05, 2	; 5
	bit_set(PCMSK0, _BV(PCINT2)); // enable contribution to PCINT0_int
  f0:	80 81       	ld	r24, Z
  f2:	84 60       	ori	r24, 0x04	; 4
  f4:	80 83       	st	Z, r24
	bit_set(DDRD, _BV(4));  // output
  f6:	54 9a       	sbi	0x0a, 4	; 10
	bit_set(PORTD, _BV(4)); // high value
  f8:	5c 9a       	sbi	0x0b, 4	; 11
	
	/* P1START input on port C, pin 3 (PCINT11_pin); output on port D, pin 5 */
	bit_clear(DDRC, _BV(3)); // input
  fa:	3b 98       	cbi	0x07, 3	; 7
	bit_set(PORTC, _BV(3));  // pull-up
  fc:	43 9a       	sbi	0x08, 3	; 8
	bit_set(PCMSK1, _BV(PCINT11)); // enable contribution to PCINT1_int
  fe:	ec e6       	ldi	r30, 0x6C	; 108
 100:	f0 e0       	ldi	r31, 0x00	; 0
 102:	80 81       	ld	r24, Z
 104:	88 60       	ori	r24, 0x08	; 8
 106:	80 83       	st	Z, r24
	bit_set(DDRD, _BV(5));  // output
 108:	55 9a       	sbi	0x0a, 5	; 10
	bit_set(PORTD, _BV(5)); // high value
 10a:	5d 9a       	sbi	0x0b, 5	; 11
	
	/* enable interrupts */
	bit_set(PCICR, _BV(PCIE0)); // PCINT0_int
 10c:	e8 e6       	ldi	r30, 0x68	; 104
 10e:	f0 e0       	ldi	r31, 0x00	; 0
 110:	80 81       	ld	r24, Z
 112:	81 60       	ori	r24, 0x01	; 1
 114:	80 83       	st	Z, r24
	bit_set(PCICR, _BV(PCIE1)); // PCINT1_int
 116:	80 81       	ld	r24, Z
 118:	82 60       	ori	r24, 0x02	; 2
 11a:	80 83       	st	Z, r24
	//bit_set(PCICR, _BV(PCIE2)); // PCINT2_int
}
 11c:	08 95       	ret

0000011e <debug>:
#include <avr/io.h>

extern void USART_Transmit(uint8_t data);

void debug(const char *text)
{
 11e:	ef 92       	push	r14
 120:	ff 92       	push	r15
 122:	cf 93       	push	r28
 124:	df 93       	push	r29
 126:	e8 2e       	mov	r14, r24
 128:	e7 01       	movw	r28, r14
 12a:	7e 01       	movw	r14, r28
 12c:	f9 2e       	mov	r15, r25
 12e:	e7 01       	movw	r28, r14
	const char *ptr = text;
	while (*ptr != '\0')
 130:	01 c0       	rjmp	.+2      	; 0x134 <debug+0x16>
	{
		USART_Transmit(*ptr++);
 132:	ee d0       	rcall	.+476    	; 0x310 <USART_Transmit>
extern void USART_Transmit(uint8_t data);

void debug(const char *text)
{
	const char *ptr = text;
	while (*ptr != '\0')
 134:	89 91       	ld	r24, Y+
 136:	88 23       	and	r24, r24
 138:	e1 f7       	brne	.-8      	; 0x132 <debug+0x14>
	{
		USART_Transmit(*ptr++);
	}
}
 13a:	df 91       	pop	r29
 13c:	cf 91       	pop	r28
 13e:	ff 90       	pop	r15
 140:	ef 90       	pop	r14
 142:	08 95       	ret

00000144 <debughex>:

void debughex(uint8_t c)
{
 144:	1f 93       	push	r17
 146:	18 2f       	mov	r17, r24
	switch (c)
 148:	e1 2f       	mov	r30, r17
 14a:	f0 e0       	ldi	r31, 0x00	; 0
 14c:	e0 31       	cpi	r30, 0x10	; 16
 14e:	f1 05       	cpc	r31, r1
 150:	a8 f5       	brcc	.+106    	; 0x1bc <debughex+0x78>
 152:	e6 5e       	subi	r30, 0xE6	; 230
 154:	ff 4f       	sbci	r31, 0xFF	; 255
 156:	09 94       	ijmp
	{
		case 0: debug("0"); break;
 158:	80 e0       	ldi	r24, 0x00	; 0
 15a:	91 e0       	ldi	r25, 0x01	; 1
 15c:	2c c0       	rjmp	.+88     	; 0x1b6 <debughex+0x72>
		case 1: debug("1"); break;
 15e:	82 e0       	ldi	r24, 0x02	; 2
 160:	91 e0       	ldi	r25, 0x01	; 1
 162:	29 c0       	rjmp	.+82     	; 0x1b6 <debughex+0x72>
		case 2: debug("2"); break;
 164:	84 e0       	ldi	r24, 0x04	; 4
 166:	91 e0       	ldi	r25, 0x01	; 1
 168:	26 c0       	rjmp	.+76     	; 0x1b6 <debughex+0x72>
		case 3: debug("3"); break;
 16a:	86 e0       	ldi	r24, 0x06	; 6
 16c:	91 e0       	ldi	r25, 0x01	; 1
 16e:	23 c0       	rjmp	.+70     	; 0x1b6 <debughex+0x72>
		case 4: debug("4"); break;
 170:	88 e0       	ldi	r24, 0x08	; 8
 172:	91 e0       	ldi	r25, 0x01	; 1
 174:	20 c0       	rjmp	.+64     	; 0x1b6 <debughex+0x72>
		case 5: debug("5"); break;
 176:	8a e0       	ldi	r24, 0x0A	; 10
 178:	91 e0       	ldi	r25, 0x01	; 1
 17a:	1d c0       	rjmp	.+58     	; 0x1b6 <debughex+0x72>
		case 6: debug("6"); break;
 17c:	8c e0       	ldi	r24, 0x0C	; 12
 17e:	91 e0       	ldi	r25, 0x01	; 1
 180:	1a c0       	rjmp	.+52     	; 0x1b6 <debughex+0x72>
		case 7: debug("7"); break;
 182:	8e e0       	ldi	r24, 0x0E	; 14
 184:	91 e0       	ldi	r25, 0x01	; 1
 186:	17 c0       	rjmp	.+46     	; 0x1b6 <debughex+0x72>
		case 8: debug("8"); break;
 188:	80 e1       	ldi	r24, 0x10	; 16
 18a:	91 e0       	ldi	r25, 0x01	; 1
 18c:	14 c0       	rjmp	.+40     	; 0x1b6 <debughex+0x72>
		case 9: debug("9"); break;
 18e:	82 e1       	ldi	r24, 0x12	; 18
 190:	91 e0       	ldi	r25, 0x01	; 1
 192:	11 c0       	rjmp	.+34     	; 0x1b6 <debughex+0x72>
		case 10: debug("a"); break;
 194:	84 e1       	ldi	r24, 0x14	; 20
 196:	91 e0       	ldi	r25, 0x01	; 1
 198:	0e c0       	rjmp	.+28     	; 0x1b6 <debughex+0x72>
		case 11: debug("b"); break;
 19a:	86 e1       	ldi	r24, 0x16	; 22
 19c:	91 e0       	ldi	r25, 0x01	; 1
 19e:	0b c0       	rjmp	.+22     	; 0x1b6 <debughex+0x72>
		case 12: debug("c"); break;
 1a0:	88 e1       	ldi	r24, 0x18	; 24
 1a2:	91 e0       	ldi	r25, 0x01	; 1
 1a4:	08 c0       	rjmp	.+16     	; 0x1b6 <debughex+0x72>
		case 13: debug("d"); break;
 1a6:	8a e1       	ldi	r24, 0x1A	; 26
 1a8:	91 e0       	ldi	r25, 0x01	; 1
 1aa:	05 c0       	rjmp	.+10     	; 0x1b6 <debughex+0x72>
		case 14: debug("e"); break;
 1ac:	8c e1       	ldi	r24, 0x1C	; 28
 1ae:	91 e0       	ldi	r25, 0x01	; 1
 1b0:	02 c0       	rjmp	.+4      	; 0x1b6 <debughex+0x72>
		case 15: debug("f"); break;
 1b2:	8e e1       	ldi	r24, 0x1E	; 30
 1b4:	91 e0       	ldi	r25, 0x01	; 1
 1b6:	b3 df       	rcall	.-154    	; 0x11e <debug>
		default:
			debughex(c >> 8);
			debughex(c & 0x0f);	
			break;
	}
}
 1b8:	1f 91       	pop	r17
 1ba:	08 95       	ret
		case 12: debug("c"); break;
		case 13: debug("d"); break;
		case 14: debug("e"); break;
		case 15: debug("f"); break;
		default:
			debughex(c >> 8);
 1bc:	80 e0       	ldi	r24, 0x00	; 0
 1be:	c2 df       	rcall	.-124    	; 0x144 <debughex>
			debughex(c & 0x0f);	
 1c0:	1f 70       	andi	r17, 0x0F	; 15
			break;
 1c2:	c2 cf       	rjmp	.-124    	; 0x148 <debughex+0x4>

000001c4 <debugln>:
	}
}

void debugln(const char *text)
{
	debug(text);
 1c4:	ac df       	rcall	.-168    	; 0x11e <debug>
	USART_Transmit('\r');
 1c6:	8d e0       	ldi	r24, 0x0D	; 13
 1c8:	a3 d0       	rcall	.+326    	; 0x310 <USART_Transmit>
	USART_Transmit('\n');
 1ca:	8a e0       	ldi	r24, 0x0A	; 10
 1cc:	a1 d0       	rcall	.+322    	; 0x310 <USART_Transmit>
}
 1ce:	08 95       	ret

000001d0 <__vector_3>:
uint8_t portB = 0;
uint8_t portC = 0;

/* interrupt vector for PCINT0_int pin change interrupt */
ISR(PCINT0_vect)
{
 1d0:	1f 92       	push	r1
 1d2:	0f 92       	push	r0
 1d4:	0f b6       	in	r0, 0x3f	; 63
 1d6:	0f 92       	push	r0
 1d8:	11 24       	eor	r1, r1
 1da:	0f 93       	push	r16
 1dc:	1f 93       	push	r17
 1de:	2f 93       	push	r18
 1e0:	3f 93       	push	r19
 1e2:	4f 93       	push	r20
 1e4:	5f 93       	push	r21
 1e6:	6f 93       	push	r22
 1e8:	7f 93       	push	r23
 1ea:	8f 93       	push	r24
 1ec:	9f 93       	push	r25
 1ee:	af 93       	push	r26
 1f0:	bf 93       	push	r27
 1f2:	ef 93       	push	r30
 1f4:	ff 93       	push	r31
	uint8_t newB = PINB;
 1f6:	13 b1       	in	r17, 0x03	; 3
	uint8_t change = newB ^ portB;
 1f8:	00 91 4a 01 	lds	r16, 0x014A
 1fc:	01 27       	eor	r16, r17
	portB = newB;
 1fe:	10 93 4a 01 	sts	0x014A, r17
	if (change & _BV(0))
 202:	00 ff       	sbrs	r16, 0
 204:	03 c0       	rjmp	.+6      	; 0x20c <__vector_3+0x3c>
	{
		Autofire_P1B1_Changed(newB & 1);
 206:	81 2f       	mov	r24, r17
 208:	81 70       	andi	r24, 0x01	; 1
 20a:	40 df       	rcall	.-384    	; 0x8c <Autofire_P1B1_Changed>
	}
	if (change & _BV(1))
 20c:	01 ff       	sbrs	r16, 1
 20e:	04 c0       	rjmp	.+8      	; 0x218 <__vector_3+0x48>
	{
		Autofire_P1B2_Changed((newB >> 1) & 1);
 210:	81 2f       	mov	r24, r17
 212:	86 95       	lsr	r24
 214:	81 70       	andi	r24, 0x01	; 1
 216:	40 df       	rcall	.-384    	; 0x98 <Autofire_P1B2_Changed>
	}
	if (change & _BV(2))
 218:	02 ff       	sbrs	r16, 2
 21a:	05 c0       	rjmp	.+10     	; 0x226 <__vector_3+0x56>
	{
		Autofire_P1B3_Changed((newB >> 2) & 1);
 21c:	81 2f       	mov	r24, r17
 21e:	86 95       	lsr	r24
 220:	86 95       	lsr	r24
 222:	81 70       	andi	r24, 0x01	; 1
 224:	3f df       	rcall	.-386    	; 0xa4 <Autofire_P1B3_Changed>
	}
}
 226:	ff 91       	pop	r31
 228:	ef 91       	pop	r30
 22a:	bf 91       	pop	r27
 22c:	af 91       	pop	r26
 22e:	9f 91       	pop	r25
 230:	8f 91       	pop	r24
 232:	7f 91       	pop	r23
 234:	6f 91       	pop	r22
 236:	5f 91       	pop	r21
 238:	4f 91       	pop	r20
 23a:	3f 91       	pop	r19
 23c:	2f 91       	pop	r18
 23e:	1f 91       	pop	r17
 240:	0f 91       	pop	r16
 242:	0f 90       	pop	r0
 244:	0f be       	out	0x3f, r0	; 63
 246:	0f 90       	pop	r0
 248:	1f 90       	pop	r1
 24a:	18 95       	reti

0000024c <__vector_4>:

/* interrupt vector for PCINT1_int pin change interrupt */
ISR(PCINT1_vect)
{
 24c:	1f 92       	push	r1
 24e:	0f 92       	push	r0
 250:	0f b6       	in	r0, 0x3f	; 63
 252:	0f 92       	push	r0
 254:	11 24       	eor	r1, r1
 256:	2f 93       	push	r18
 258:	3f 93       	push	r19
 25a:	4f 93       	push	r20
 25c:	5f 93       	push	r21
 25e:	6f 93       	push	r22
 260:	7f 93       	push	r23
 262:	8f 93       	push	r24
 264:	9f 93       	push	r25
 266:	af 93       	push	r26
 268:	bf 93       	push	r27
 26a:	ef 93       	push	r30
 26c:	ff 93       	push	r31
	uint8_t newC = PINC;
 26e:	86 b1       	in	r24, 0x06	; 6
	uint8_t change = newC ^ portC;
 270:	90 91 4b 01 	lds	r25, 0x014B
 274:	98 27       	eor	r25, r24
	portC = newC;
 276:	80 93 4b 01 	sts	0x014B, r24
	if (change & _BV(3))
 27a:	93 ff       	sbrs	r25, 3
 27c:	05 c0       	rjmp	.+10     	; 0x288 <__vector_4+0x3c>
	{
		Autofire_P1START_Changed((newC >> 3) & 1);
 27e:	86 95       	lsr	r24
 280:	86 95       	lsr	r24
 282:	86 95       	lsr	r24
 284:	81 70       	andi	r24, 0x01	; 1
 286:	14 df       	rcall	.-472    	; 0xb0 <Autofire_P1START_Changed>
	}
}
 288:	ff 91       	pop	r31
 28a:	ef 91       	pop	r30
 28c:	bf 91       	pop	r27
 28e:	af 91       	pop	r26
 290:	9f 91       	pop	r25
 292:	8f 91       	pop	r24
 294:	7f 91       	pop	r23
 296:	6f 91       	pop	r22
 298:	5f 91       	pop	r21
 29a:	4f 91       	pop	r20
 29c:	3f 91       	pop	r19
 29e:	2f 91       	pop	r18
 2a0:	0f 90       	pop	r0
 2a2:	0f be       	out	0x3f, r0	; 63
 2a4:	0f 90       	pop	r0
 2a6:	1f 90       	pop	r1
 2a8:	18 95       	reti

000002aa <main>:
{
	//USART_Init();
	//printf("USART initialized.\n");
	//Video_Init();
	//printf("Video initialized.\n");
	Autofire_Init();
 2aa:	08 df       	rcall	.-496    	; 0xbc <Autofire_Init>
	printf("Autofire initialized.\n");
 2ac:	80 e2       	ldi	r24, 0x20	; 32
 2ae:	91 e0       	ldi	r25, 0x01	; 1
 2b0:	a1 d0       	rcall	.+322    	; 0x3f4 <puts>

	/* Output led on port C, pin 2 */
	bit_set(DDRC, _BV(2));  // output
 2b2:	3a 9a       	sbi	0x07, 2	; 7
	bit_set(PORTC, _BV(2));
 2b4:	42 9a       	sbi	0x08, 2	; 8

	sei();
 2b6:	78 94       	sei
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 2b8:	8f e7       	ldi	r24, 0x7F	; 127
 2ba:	94 e8       	ldi	r25, 0x84	; 132
 2bc:	ae e1       	ldi	r26, 0x1E	; 30
 2be:	81 50       	subi	r24, 0x01	; 1
 2c0:	90 40       	sbci	r25, 0x00	; 0
 2c2:	a0 40       	sbci	r26, 0x00	; 0
 2c4:	e1 f7       	brne	.-8      	; 0x2be <main+0x14>
 2c6:	00 c0       	rjmp	.+0      	; 0x2c8 <main+0x1e>
 2c8:	00 00       	nop
	{
		i++;
		
		/* Blinks the LED */
		_delay_ms(500);
		bit_clear(PORTC, _BV(2));
 2ca:	42 98       	cbi	0x08, 2	; 8
 2cc:	8f e7       	ldi	r24, 0x7F	; 127
 2ce:	94 e8       	ldi	r25, 0x84	; 132
 2d0:	ae e1       	ldi	r26, 0x1E	; 30
 2d2:	81 50       	subi	r24, 0x01	; 1
 2d4:	90 40       	sbci	r25, 0x00	; 0
 2d6:	a0 40       	sbci	r26, 0x00	; 0
 2d8:	e1 f7       	brne	.-8      	; 0x2d2 <main+0x28>
 2da:	00 c0       	rjmp	.+0      	; 0x2dc <main+0x32>
 2dc:	00 00       	nop
		_delay_ms(500);
		bit_set(PORTC, _BV(2));
 2de:	42 9a       	sbi	0x08, 2	; 8
 2e0:	eb cf       	rjmp	.-42     	; 0x2b8 <main+0xe>

000002e2 <USART_Init>:
static FILE mystdout = FDEV_SETUP_STREAM(uart_putchar, NULL, _FDEV_SETUP_WRITE);

void USART_Init()
{
	/* Init USART clock */
	UBRR0H = UBRRH_VALUE;
 2e2:	10 92 c5 00 	sts	0x00C5, r1
	UBRR0L = UBRRL_VALUE;
 2e6:	8a e0       	ldi	r24, 0x0A	; 10
 2e8:	80 93 c4 00 	sts	0x00C4, r24
	#if USE_2X
	UCSR0A |= (1 << U2X0);
	#else
	UCSR0A &= ~(1 << U2X0);
 2ec:	e0 ec       	ldi	r30, 0xC0	; 192
 2ee:	f0 e0       	ldi	r31, 0x00	; 0
 2f0:	80 81       	ld	r24, Z
 2f2:	8d 7f       	andi	r24, 0xFD	; 253
 2f4:	80 83       	st	Z, r24
	#endif

	/* Enable receiver and transmitter and receive interrupt */
	UCSR0B = _BV(RXEN0)|_BV(TXEN0)|_BV(RXCIE0);
 2f6:	88 e9       	ldi	r24, 0x98	; 152
 2f8:	80 93 c1 00 	sts	0x00C1, r24

	/* Set frame format: 8data, 1stop bit */
	UCSR0C = (0<<USBS0)|(3<<UCSZ00);
 2fc:	86 e0       	ldi	r24, 0x06	; 6
 2fe:	80 93 c2 00 	sts	0x00C2, r24

	/* Register USART as standard output */
	stdout = &mystdout;
 302:	8b e3       	ldi	r24, 0x3B	; 59
 304:	91 e0       	ldi	r25, 0x01	; 1
 306:	90 93 53 01 	sts	0x0153, r25
 30a:	80 93 52 01 	sts	0x0152, r24
}
 30e:	08 95       	ret

00000310 <USART_Transmit>:

void USART_Transmit(uint8_t data)
{
	/* Wait for empty transmit buffer */
	while (!(UCSR0A & _BV(UDRE0)));
 310:	90 91 c0 00 	lds	r25, 0x00C0
 314:	95 ff       	sbrs	r25, 5
 316:	fc cf       	rjmp	.-8      	; 0x310 <USART_Transmit>
	/* Put data into buffer, sends the data */
	UDR0 = data;
 318:	80 93 c6 00 	sts	0x00C6, r24
}
 31c:	08 95       	ret

0000031e <uart_putchar>:
	/* Get and return received data from buffer */
	return UDR0;
}

static int uart_putchar(char c, FILE *stream)
{
 31e:	1f 93       	push	r17
 320:	18 2f       	mov	r17, r24
	if (c == '\n')
 322:	8a 30       	cpi	r24, 0x0A	; 10
 324:	11 f4       	brne	.+4      	; 0x32a <uart_putchar+0xc>
		uart_putchar('\r', stream);
 326:	8d e0       	ldi	r24, 0x0D	; 13
 328:	fa df       	rcall	.-12     	; 0x31e <uart_putchar>
	USART_Transmit(c);
 32a:	81 2f       	mov	r24, r17
 32c:	f1 df       	rcall	.-30     	; 0x310 <USART_Transmit>
}
 32e:	1f 91       	pop	r17
 330:	08 95       	ret

00000332 <USART_Receive>:
}

uint8_t USART_Receive()
{
	/* Wait for data to be received */
	while (!(UCSR0A & _BV(RXC0)));
 332:	80 91 c0 00 	lds	r24, 0x00C0
 336:	87 ff       	sbrs	r24, 7
 338:	fc cf       	rjmp	.-8      	; 0x332 <USART_Receive>
	/* Get and return received data from buffer */
	return UDR0;
 33a:	80 91 c6 00 	lds	r24, 0x00C6
}
 33e:	08 95       	ret

00000340 <__vector_18>:
	USART_Transmit(c);
}

/* interrupt vector for USART data reception */
ISR(USART_RX_vect)
{
 340:	1f 92       	push	r1
 342:	0f 92       	push	r0
 344:	0f b6       	in	r0, 0x3f	; 63
 346:	0f 92       	push	r0
 348:	11 24       	eor	r1, r1
 34a:	2f 93       	push	r18
 34c:	3f 93       	push	r19
 34e:	4f 93       	push	r20
 350:	5f 93       	push	r21
 352:	6f 93       	push	r22
 354:	7f 93       	push	r23
 356:	8f 93       	push	r24
 358:	9f 93       	push	r25
 35a:	af 93       	push	r26
 35c:	bf 93       	push	r27
 35e:	ef 93       	push	r30
 360:	ff 93       	push	r31
	uint8_t c = USART_Receive();
 362:	e7 df       	rcall	.-50     	; 0x332 <USART_Receive>
	if (c == '\r')
 364:	8d 30       	cpi	r24, 0x0D	; 13
 366:	21 f4       	brne	.+8      	; 0x370 <__vector_18+0x30>
	{
		printf("\nOK.\n");
 368:	86 e3       	ldi	r24, 0x36	; 54
 36a:	91 e0       	ldi	r25, 0x01	; 1
 36c:	43 d0       	rcall	.+134    	; 0x3f4 <puts>
 36e:	01 c0       	rjmp	.+2      	; 0x372 <__vector_18+0x32>
	}
	else
	{
		USART_Transmit(c);
 370:	cf df       	rcall	.-98     	; 0x310 <USART_Transmit>
	}
}
 372:	ff 91       	pop	r31
 374:	ef 91       	pop	r30
 376:	bf 91       	pop	r27
 378:	af 91       	pop	r26
 37a:	9f 91       	pop	r25
 37c:	8f 91       	pop	r24
 37e:	7f 91       	pop	r23
 380:	6f 91       	pop	r22
 382:	5f 91       	pop	r21
 384:	4f 91       	pop	r20
 386:	3f 91       	pop	r19
 388:	2f 91       	pop	r18
 38a:	0f 90       	pop	r0
 38c:	0f be       	out	0x3f, r0	; 63
 38e:	0f 90       	pop	r0
 390:	1f 90       	pop	r1
 392:	18 95       	reti

00000394 <getCurrentTime>:

uint16_t timer1overflows = 0;

uint32_t getCurrentTime()
{
	uint32_t res = timer1overflows;
 394:	20 91 4c 01 	lds	r18, 0x014C
 398:	30 91 4d 01 	lds	r19, 0x014D
 39c:	40 e0       	ldi	r20, 0x00	; 0
 39e:	50 e0       	ldi	r21, 0x00	; 0
	res <<= 16;
 3a0:	a9 01       	movw	r20, r18
 3a2:	33 27       	eor	r19, r19
 3a4:	22 27       	eor	r18, r18
	res |= TCNT1;
 3a6:	80 91 84 00 	lds	r24, 0x0084
 3aa:	90 91 85 00 	lds	r25, 0x0085
 3ae:	a0 e0       	ldi	r26, 0x00	; 0
 3b0:	b0 e0       	ldi	r27, 0x00	; 0
 3b2:	28 2b       	or	r18, r24
 3b4:	39 2b       	or	r19, r25
 3b6:	4a 2b       	or	r20, r26
 3b8:	5b 2b       	or	r21, r27
	return res; 
}
 3ba:	b9 01       	movw	r22, r18
 3bc:	ca 01       	movw	r24, r20
 3be:	08 95       	ret

000003c0 <__vector_13>:

/* interrupt vector for timer 1 overflow */
ISR(TIMER1_OVF_vect)
{
 3c0:	1f 92       	push	r1
 3c2:	0f 92       	push	r0
 3c4:	0f b6       	in	r0, 0x3f	; 63
 3c6:	0f 92       	push	r0
 3c8:	11 24       	eor	r1, r1
 3ca:	8f 93       	push	r24
 3cc:	9f 93       	push	r25
	timer1overflows++;
 3ce:	80 91 4c 01 	lds	r24, 0x014C
 3d2:	90 91 4d 01 	lds	r25, 0x014D
 3d6:	01 96       	adiw	r24, 0x01	; 1
 3d8:	90 93 4d 01 	sts	0x014D, r25
 3dc:	80 93 4c 01 	sts	0x014C, r24
}
 3e0:	9f 91       	pop	r25
 3e2:	8f 91       	pop	r24
 3e4:	0f 90       	pop	r0
 3e6:	0f be       	out	0x3f, r0	; 63
 3e8:	0f 90       	pop	r0
 3ea:	1f 90       	pop	r1
 3ec:	18 95       	reti

000003ee <Video_Init>:
	/*
	TCCR1B |= _BV(CS11) | _BV(CS10); // enabled with div64 prescaleer
	TIMSK1 |= _BV(TOIE1); // Overflow Interrupt Enable
	*/
	#endif
 3ee:	08 95       	ret

000003f0 <exit>:
 3f0:	f8 94       	cli
 3f2:	4f c0       	rjmp	.+158    	; 0x492 <_exit>

000003f4 <puts>:
 3f4:	ef 92       	push	r14
 3f6:	ff 92       	push	r15
 3f8:	0f 93       	push	r16
 3fa:	1f 93       	push	r17
 3fc:	cf 93       	push	r28
 3fe:	df 93       	push	r29
 400:	8c 01       	movw	r16, r24
 402:	e0 91 52 01 	lds	r30, 0x0152
 406:	f0 91 53 01 	lds	r31, 0x0153
 40a:	83 81       	ldd	r24, Z+3	; 0x03
 40c:	81 ff       	sbrs	r24, 1
 40e:	1f c0       	rjmp	.+62     	; 0x44e <puts+0x5a>
 410:	c0 e0       	ldi	r28, 0x00	; 0
 412:	d0 e0       	ldi	r29, 0x00	; 0
 414:	0a c0       	rjmp	.+20     	; 0x42a <puts+0x36>
 416:	db 01       	movw	r26, r22
 418:	18 96       	adiw	r26, 0x08	; 8
 41a:	ed 91       	ld	r30, X+
 41c:	fc 91       	ld	r31, X
 41e:	19 97       	sbiw	r26, 0x09	; 9
 420:	09 95       	icall
 422:	00 97       	sbiw	r24, 0x00	; 0
 424:	11 f0       	breq	.+4      	; 0x42a <puts+0x36>
 426:	cf ef       	ldi	r28, 0xFF	; 255
 428:	df ef       	ldi	r29, 0xFF	; 255
 42a:	f8 01       	movw	r30, r16
 42c:	81 91       	ld	r24, Z+
 42e:	8f 01       	movw	r16, r30
 430:	60 91 52 01 	lds	r22, 0x0152
 434:	70 91 53 01 	lds	r23, 0x0153
 438:	88 23       	and	r24, r24
 43a:	69 f7       	brne	.-38     	; 0x416 <puts+0x22>
 43c:	db 01       	movw	r26, r22
 43e:	18 96       	adiw	r26, 0x08	; 8
 440:	ed 91       	ld	r30, X+
 442:	fc 91       	ld	r31, X
 444:	19 97       	sbiw	r26, 0x09	; 9
 446:	8a e0       	ldi	r24, 0x0A	; 10
 448:	09 95       	icall
 44a:	00 97       	sbiw	r24, 0x00	; 0
 44c:	11 f0       	breq	.+4      	; 0x452 <puts+0x5e>
 44e:	cf ef       	ldi	r28, 0xFF	; 255
 450:	df ef       	ldi	r29, 0xFF	; 255
 452:	ce 01       	movw	r24, r28
 454:	cd b7       	in	r28, 0x3d	; 61
 456:	de b7       	in	r29, 0x3e	; 62
 458:	e6 e0       	ldi	r30, 0x06	; 6
 45a:	0c c0       	rjmp	.+24     	; 0x474 <__epilogue_restores__+0x18>

0000045c <__epilogue_restores__>:
 45c:	2a 88       	ldd	r2, Y+18	; 0x12
 45e:	39 88       	ldd	r3, Y+17	; 0x11
 460:	48 88       	ldd	r4, Y+16	; 0x10
 462:	5f 84       	ldd	r5, Y+15	; 0x0f
 464:	6e 84       	ldd	r6, Y+14	; 0x0e
 466:	7d 84       	ldd	r7, Y+13	; 0x0d
 468:	8c 84       	ldd	r8, Y+12	; 0x0c
 46a:	9b 84       	ldd	r9, Y+11	; 0x0b
 46c:	aa 84       	ldd	r10, Y+10	; 0x0a
 46e:	b9 84       	ldd	r11, Y+9	; 0x09
 470:	c8 84       	ldd	r12, Y+8	; 0x08
 472:	df 80       	ldd	r13, Y+7	; 0x07
 474:	ee 80       	ldd	r14, Y+6	; 0x06
 476:	fd 80       	ldd	r15, Y+5	; 0x05
 478:	0c 81       	ldd	r16, Y+4	; 0x04
 47a:	1b 81       	ldd	r17, Y+3	; 0x03
 47c:	aa 81       	ldd	r26, Y+2	; 0x02
 47e:	b9 81       	ldd	r27, Y+1	; 0x01
 480:	ce 0f       	add	r28, r30
 482:	d1 1d       	adc	r29, r1
 484:	0f b6       	in	r0, 0x3f	; 63
 486:	f8 94       	cli
 488:	de bf       	out	0x3e, r29	; 62
 48a:	0f be       	out	0x3f, r0	; 63
 48c:	cd bf       	out	0x3d, r28	; 61
 48e:	ed 01       	movw	r28, r26
 490:	08 95       	ret

00000492 <_exit>:
 492:	f8 94       	cli

00000494 <__stop_program>:
 494:	ff cf       	rjmp	.-2      	; 0x494 <__stop_program>
